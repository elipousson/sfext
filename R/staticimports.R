# Generated by staticimports; do not edit by hand.
# ======================================================================
# Imported from pkg:isstatic
# ======================================================================

#' Convert an alphabetical character object from A to Z into a corresponding
#' integer
#'
#' Integers and NA values are passed as is. Double or characters with no
#' corresponding Roman numeral are converting to NA values.
#'
#' @param x Character vector of length n strings to compare to dict. Typically,
#'   letters from "A" to "Z". Case sensitive.
#' @param dict Character vector to match to x. Default: LETTERS.
#' @param n Maximum character length for non-NA objects permitted. Set to NULL
#'   or >1 if dict includes objects with more than one character.
#' @param quiet If `TRUE`, suppress warnings for introduction of NA values
#'   through coercion.
##' @param call Default: [parent.frame()]. Passed to input checking functions
#'   to improve error messages.
#' @returns A length 1 integer between 1 and 26.
#' @noRd
alpha_to_int <- function(x,
                         dict = LETTERS,
                         n = 1,
                         quiet = TRUE,
                         call = parent.frame()) {
  static_check_nchar(x, n, call = call)
  x[x %in% dict] <- seq_along(dict)[dict %in% x]
  as_integer(x, quiet)
}

#' as.integer with option to suppress warnings for NA coercion
#'
#' @inheritParams base::as.integer
#' @param quiet If `TRUE`, suppress warnings about creation of NA values through
#'   coercion of object types. Default to `TRUE`.
#' @noRd
as_integer <- function(x, quiet = TRUE) {
  if (isTRUE(quiet)) {
    return(suppressWarnings(as.integer(x)))
  }

  as.integer(x)
}

#' Convert a numeric vector to a vector of numbered labels
#'
#' This function allows the creation of numbered labels for a vector using a
#' range of numbering styles.
#'
#' @param x An integer or other vector or a data.frame. An integer vector or
#'   integer column is used as the number that is converted based on the label
#'   style. If x is not an integer or data.frame with an integer column, the
#'   numbering is created based on [seq_along()].
#' @param labels Label style. Options include "arabic", "alph", "Alph", "alpha",
#'   "Alpha", "roman", or "Roman".
#' @param start Starting number or value. Letters are supported if label style
#'   is "alph", "Alph", "alpha", or  "Alpha" and Roman numerals are supported if
#'   label is "roman" or "Roman".
#' @param suffix Suffix character to follow number labels. For example, if `x =
#'   1` and `suffix = "."` the returned label would be "1."
#' @param base Base used in alphabetical number labels. Highest letter to use
#'   for alphabetical numbers. Single digit letters (A to Z) or numbers 1 to 26
#'   are supported. For example, if base is 3, alphabetical labels for numbers
#'   higher than 3 have the prior value prefixed so 3 would be "C" and 4 would
#'   be "AA". Defaults to 26 which converts 27 to "AA", 53 to "BA", etc.
#' @param cols Column name to use for added column for number labels when x is a
#'   data.frame. Defaults to "num_label". If cols is length 2, the first item in
#'   the vector is assumed to be the column name from the data.frame to use as x
#'   and the second item is used as the column name for the added column with
#'   number labels.
#' @inheritParams as_integer
#' @param call Default: [parent.frame()]. Passed to input checking functions
#'   to improve error message traceback.
#' @param pad,side If pad is not `NULL`, pass pad and side to [str_pad()] added
#'   from the [stringstatic::str_pad()] package.
#' @returns
#' - If x is a vector, function returns numeric vector if labels is
#'   "arabic" or a character vector otherwise.
#' - If x is a data.frame, [as_numbered_labels()] returns a modified data.frame
#'   with an added column with a name matching the second value of the cols
#'   parameter.
#' @noRd
as_numbered_labels <- function(x,
                               labels = "arabic",
                               start = NULL,
                               suffix = NULL,
                               base = 26,
                               cols = "num_label",
                               pad = NULL,
                               side = "left",
                               quiet = TRUE,
                               call = parent.frame()) {
  if (is.data.frame(x)) {
    num_col <- cols
    x_col <- c(1:nrow(x))

    if (length(cols) == 2) {
      num_col <- cols[2]
      static_check_name(x, cols[1])
      x_col <- x[, cols[1]]
    }

    x[[num_col]] <-
      as_numbered_labels(
        x_col, labels, start, suffix, base, cols, pad, side, quiet, call
      )

    return(x)
  }

  if (str_detect(labels, " ")) {
    start <- str_extract(labels, "(?<= ).+$")
    static_check_nchar(start, n = 1)
    labels <- str_extract(labels, "^.+(?= )")
    labels <- tolower(labels)
    if (str_detect(start, "[A-Z]")) {
      labels <- tosentence(labels)
    }
  }

  labels <-
    match.arg(
      labels, c("arabic", "alph", "Alph", "alpha", "Alpha", "roman", "Roman")
    )

  if (!is.integer(x)) {
    x <- seq_along(x)
  }

  x <- set_start_number(x, start, labels)

  num_labels <-
    switch(labels,
      "arabic" = x,
      "alph" = sapply(x, int_to_alpha,
        base = base,
        dict = letters, quiet = quiet
      ),
      "alpha" = sapply(x, int_to_alpha,
        base = base,
        dict = letters, quiet = quiet
      ),
      "Alph" = sapply(x, int_to_alpha, base = base, quiet = quiet),
      "Alpha" = sapply(x, int_to_alpha, base = base, quiet = quiet),
      "roman" = tolower(as_roman(x, quiet)),
      "Roman" = toupper(as_roman(x, quiet))
    )

  if (!is.null(pad)) {
    num_labels <- str_pad(num_labels, max(nchar(num_labels)), side, pad)
  }

  if (is.null(suffix)) {
    return(num_labels)
  }

  paste0(num_labels, suffix)
}

#' as.roman with option to suppress warnings for NA coercion
#'
#' @inheritParams utils::as.roman
#' @param quiet If `TRUE`, suppress warnings about creation of NA values through
#'   coercion of object types. Default to `TRUE`.
#' @noRd
as_roman <- function(x, quiet = TRUE) {
  if (isTRUE(quiet)) {
    return(suppressWarnings(utils::as.roman(x)))
  }

  utils::as.roman(x)
}

#' Combine multiple words into a single string
#'
#' @author Yihui Xie \email{xie@yihui.name}
#'   ([ORCID](https://orcid.org/0000-0003-0645-5666))
#'
#' @source Adapted from [knitr::combine_words()] in the
#'   [knitr](https://yihui.org/knitr/) package.
#'
#' @inherit knitr::combine_words
#' @returns A character string
#' @noRd
combine_words <- function(words,
                          sep = ", ",
                          and = " and ",
                          before = "",
                          after = before,
                          oxford_comma = TRUE) {
  n <- length(words)

  rs <- function (x) {
    if (is.null(x))
      x = as.character(x)
    x
  }

  if (n == 0) {
    return(words)
  }

  words <- paste0(before, words, after)

  if (n == 1) {
    return(rs(words))
  }

  if (n == 2) {
    return(rs(paste(words, collapse = if (is_blank(and)) sep else and)))
  }

  if (oxford_comma && grepl("^ ", and) && grepl(" $", sep)) {
    and <- gsub("^ ", "", and)
  }

  words[n] <- paste0(and, words[n])

  if (!oxford_comma) {
    words[n - 1] <- paste0(words[n - 1:0], collapse = "")
    words <- words[-n]
  }

  rs(paste(words, collapse = sep))
}

#' Does this object have all of the provided names?
#'
#' @rdname is_named
#' @name has_all_names
#' @param name Element name(s) to check.
#' @noRd
has_all_names <- function(x, name) {
  if (anyNA(c(x, name))) {
    return(FALSE)
  }

  all(utils::hasName(x, name))
}

#' Does string contain the specified file type or any file extension?
#'
#' Check if string contains any filetype or the provided filetype. If string is
#' `NULL`, returns `FALSE`.
#'
#' @param string String to be tested with or without filetype. Defaults to
#'   `NULL`.
#' @param fileext File type to test against. Optional.
#' @param ignore.case If `FALSE`, the pattern matching is case sensitive. If
#'   `TRUE`, case is ignored.
#' @seealso [isstatic::is_fileext_path()]
#' @noRd
has_fileext <- function(string = NULL, fileext = NULL, ignore.case = FALSE) {
  if (is.null(string)) {
    return(FALSE)
  }

  if (is.null(fileext)) {
    fileext <- "[a-zA-Z0-9]+"
  }

  is_fileext_path(string, fileext, ignore.case)
}

#' Do two object have an identical length?
#'
#' @param x,y Two strings or character vectors to compare.
#' @param ... Additional parameters passed to [identical()]
#' @noRd
has_same_len <- function(x, y, ...) {
  identical(length(x), length(y), ...)
}

#' Convert a integer into a corresponding letter or multi-letter string
#'
#' Character values in the provided dict (default to letters "A" to "Z") are
#' passed as is. Non-integer numeric values or characters that are not found in
#' the provided dict are converting to NA values.
#'
#' @source Adapted from the recursive solution provided by G. Grothendieck in [a
#'   May 31, 2017 StackOverflow answer](https://stackoverflow.com/a/44274075).
#'
#' @param x An integer vector or a vector that can be coerced to an integer
#'   vector
#' @param suffix Suffix character to follow alpha character, e.g. if `x = 1` and
#'   `suffix = "."` the returned label would be "A.". suffix is also used to
#'   separate values when x is greater than base, e.g. `x = 27` and `suffix =
#'   "."` returns "A.A." Defaults to `NULL`.
#' @param base If base is not numeric, it is converted to an integer with
#'   [alpha_to_int()].
#' @param dict Character vector to compare to x. Default: LETTERS.
#' @param quiet If `TRUE`, suppress warnings for introduction of NA values
#'   through coercion.
#' @returns An integer vector composed of objects between 1 and 26 with the same
#'   length as x.
#' @noRd
int_to_alpha <- function(x,
                         suffix = NULL,
                         base = 26,
                         dict = LETTERS,
                         quiet = TRUE) {
  x <- as_integer(x, quiet)

  if (!is.numeric(base)) {
    base <- alpha_to_int(base, dict)
  }

  rest <- (x - 1) %/% base

  alpha <-
    paste0(
      dict[((x - 1) %% base) + 1],
      suffix
    )

  if (rest > 0) {
    return(Recall(rest, alpha, base, dict))
  }

  alpha
}

#' Do all items in a list or vector return TRUE from a predicate function?
#'
#' @param x A list or vector passed to X parameter of [vapply()].
#' @inheritParams base::vapply
#' @inheritDotParams base::vapply -X
#' @returns `TRUE` if FUN returns `TRUE` for all elements of x or `FALSE` if any
#'   element returns `FALSE`.
#' @seealso [isstatic::is_any()]
#' @noRd
is_all <- function(x, FUN, ...) {
  all(vapply(x, FUN, FUN.VALUE = TRUE, ...))
}

#' Do any items in a list or vector return `TRUE` from a predicate function?
#'
#' @param x A list or vector passed to [vapply()].
#' @inheritParams base::vapply
#' @inheritDotParams base::vapply -X
#' @returns `TRUE` if FUN returns `TRUE` for any element of x or `FALSE` if all
#'   elements return `FALSE`.
#' @seealso [isstatic::is_all()]
#' @noRd
is_any <- function(x, FUN, ...) {
  any(vapply(x, FUN, FUN.VALUE = TRUE, ...))
}

#' Are any of x in y?
#'
#' @param x Object to be tested.
#' @param y Vector to compare x to.
#' @noRd
is_any_in <- function(x, y) {
  any(x %in% y)
}

#' @inherit xfun::is_blank
#'
#' @author Yihui Xie \email{xie@yihui.name}
#'   ([ORCID](https://orcid.org/0000-0003-0645-5666))
#'
#' @source Adapted from [xfun::is_blank()] in the
#'   [xfun](https://yihui.org/xfun/) package.
#'
#' @examples
#' is_blank("")
#' is_blank("abc")
#' is_blank(c("", "  ", "\n\t"))
#' is_blank(c("", " ", "abc"))
#' @noRd
is_blank <- function(x) {
  all(grepl("^\\s*$", x))
}

#' [is_csv_fileext]: Does this text end with a CSV file extension?
#'
#' @name is_csv_fileext
#' @rdname is_fileext_path
#' @noRd
is_csv_fileext <- function(x, ignore.case = TRUE) {
  is_fileext_path(x, "csv", ignore.case)
}

#' - [is_esri_url()]: Is an object an ArcGIS MapServer or FeatureServer URL?
#'
#' @name is_esri_url
#' @rdname is_url
#' @noRd
is_esri_url <- function(x) {
  is_url(x) & grepl("/MapServer|/FeatureServer", x)
}

#' [is_excel_fileext]: Does this text end with a XLS or XLSX file extension?
#'
#' @name is_excel_fileext
#' @rdname is_fileext_path
#' @noRd
is_excel_fileext <- function(x, ignore.case = TRUE) {
  is_fileext_path(x, c("xls", "xlsx"), ignore.case)
}

#' Does this text end in the provided file extension?
#'
#' @param x A character vector to check for matches, or an object which can be
#'   coerced by [as.character()] to a character vector.
#' @param fileext A file extension to compare to x. Required. If a vector of
#'   multiple extensions are provided, returns `TRUE` for any match.
#' @inheritParams base::grepl
#' @seealso [isstatic::has_fileext()]
#' @noRd
is_fileext_path <- function(x, fileext, ignore.case = TRUE) {
  grepl(
    paste0("\\.", paste0(fileext, collapse = "|"), "$(?!\\.)"),
    x,
    ignore.case = ignore.case, perl = TRUE
  )
}

#' [is_geojson_fileext]: Does this text end with a GeoJSON file extension?
#'
#' @name is_geojson_fileext
#' @rdname is_fileext_path
#' @noRd
is_geojson_fileext <- function(x, ignore.case = TRUE) {
  is_fileext_path(x, "geojson", ignore.case)
}

#' - [is_gist_url()]: Is an object a URL for a GitHub Gist?
#'
#' @name is_gist_url
#' @rdname is_url
#' @noRd
is_gist_url <- function(x) {
  grepl("^https://gist.github.com/", x)
}

#' - [is_gmap_url()]: Is an object a Google Maps URL?
#'
#' @name is_gmap_url
#' @rdname is_url
#' @noRd
is_gmap_url <- function(x) {
  grepl("^https://www.google.com/maps/", x)
}

#' - [is_gsheet_url()]: Is an object a Google Sheets URL?
#'
#' @name is_gsheet_url
#' @rdname is_url
#' @noRd
is_gsheet_url <- function(x) {
  grepl("^https://docs.google.com/spreadsheets/", x)
}

#' [is_rda_fileext]: Does this text end with a rda file extension?
#'
#' @name is_rda_fileext
#' @rdname is_fileext_path
#' @noRd
is_rda_fileext <- function(x, ignore.case = TRUE) {
  is_fileext_path(x, "rda", ignore.case)
}

#' [is_rdata_fileext]: Does this text end with a rds, rda, or RData file extension?
#'
#' @name is_rdata_fileext
#' @rdname is_fileext_path
#' @noRd
is_rdata_fileext <- function(x, ignore.case = TRUE) {
  any(
    c(
      is_rda_fileext(x, ignore.case),
      is_rds_fileext(x, ignore.case),
      is_fileext_path(x, "RData", ignore.case)
    )
  )
}

#' [is_rds_fileext]: Does this text end with a rds file extension?
#'
#' @name is_rds_fileext
#' @rdname is_fileext_path
#' @noRd
is_rds_fileext <- function(x, ignore.case = TRUE) {
  is_fileext_path(x, "rds", ignore.case)
}

#' Is this a unit class object?
#'
#' @param x Object to be tested.
#' @noRd
is_unit <- function(x) {
  inherits(x, "unit")
}

#' Is this a units class object?
#'
#' @param x Object to be tested.
#' @noRd
is_units <- function(x) {
  inherits(x, "units")
}

#' Is an object a URL?
#'
#' @param x A object to be tested.
#' @noRd
is_url <- function(x) {
  grepl(
    "http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+",
    x
  )
}

#' Simple helper for pluralizing words
#'
#' @noRd
plural_words <- function(words,
                         n = 1,
                         suffix = "s",
                         before = "",
                         after = "",
                         replacement = NULL) {
  words <- paste0(before, words, after)

  if (is.null(replacement)) {
    replacement <- paste0(words, suffix)
  }

  if (n > 1) {
    return(replacement)
  }

  words
}

#' Convert a Roman numeral character object into a corresponding integer
#'
#' Integers and NA objects are passed as is. Double numeric objects or
#' characters with no corresponding Roman numeral are converting to NA values.
#'
#' @param x An integer vector or a character vector with characters representing
#'   Roman numerals.
#' @param quiet If `TRUE`, suppress warnings for introduction of NA values
#'   through coercion.
#' @noRd
roman_to_int <- function(x, quiet = TRUE) {
  as_integer(as_roman(x, quiet), quiet)
}

#' Set start number for numeric vector x
#'
#' Helper for [as_numbered_labels()].
#'
#' @inheritParams as_numbered_labels
#' @noRd
set_start_number <- function(x, start = NULL, labels = "arabic") {
  if (is.null(start)) {
    start <- 1
  }

  if (!is.numeric(start)) {
    if (labels %in% c("alph", "Alph", "alpha", "Alpha")) {
      start <- alpha_to_int(toupper(start))
    }

    if (labels %in% c("roman", "Roman")) {
      start <- roman_to_int(start)
    }
  }

  x + (start - 1)
}

#' @name static_check_if
#' @rdname static_check
#' @noRd
static_check_if <- function(condition, message = NULL, call = parent.frame()) {
  if (isTRUE(condition)) {
    return(invisible(NULL))
  }

  stop(
    message,
    call. = call
  )
}

#' @name static_check_name
#' @rdname static_check
#' @noRd
static_check_name <- function(x, name = NULL, call = parent.frame()) {
  static_check_if(
    condition = has_all_names(x, name),
    message = paste0(
      "`x` must have ", plural_words("name", length(name), after = " "), name,
      ", but ", combine_words(name[!(name %in% names(x))]), " are all missing."
    ),
    call = call
  )
}

#' @name static_check_nchar
#' @rdname static_check
#' @noRd
static_check_nchar <- function(x, n = 1, ..., call = parent.frame()) {
  num_char <- unique(nchar(x[!is.na(x)], ...))

  message <- num_char

  if (length(num_char) > 1) {
    message <- paste("a range from", min(num_char), "to", max(num_char))
  }

  message <- paste0(
    "All objects in `x` must have ", n, plural_words(" character", n),
    ", not ", message, "."
  )

  static_check_if(
    condition = is.null(n) | all(n == num_char),
    message = message,
    call = call
  )
}

#'
#' @name str_add_fileext
#' @rdname str_fileext
#' @noRd
str_add_fileext <- function(string, fileext = NULL) {
  if (is.null(fileext) || !is.null(fileext) && all(has_fileext(string, fileext))) {
    return(string)
  }

  if (any(has_fileext(string))) {
    string <- str_remove_fileext(string)
  }

  str_c(string, ".", fileext)
}

#' Join multiple strings into a single string
#'
#' Dependency-free drop-in alternative for `stringr::str_c()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param ... One or more character vectors.
#'   Zero length arguments are removed.
#'   Short arguments are recycled to the length of the longest.
#'
#'   Like most other R functions, missing values are "infectious":
#'   whenever a missing value is combined with another string
#'   the result will always be missing.
#'   Use `str_replace_na()` to convert `NA` to "NA"
#'
#' @param sep String to insert between input vectors.
#'
#' @param collapse
#'   Optional string used to combine input vectors into single string.
#'
#' @return If `collapse = NULL` (the default) a character vector
#'   with length equal to the longest input string.
#'   If collapse is non-`NULL`, a character vector of length 1.
#' @noRd
str_c <- function(..., sep = "", collapse = NULL) {
  stopifnot(
    "`sep` must be a single string, not a character vector." = length(sep) == 1,
    "`collapse` must be a single string or `NULL`, not a character vector." =
      length(collapse) == 1 || is.null(collapse)
  )

  strings <- Filter(function(x) !is.null(x), list(...))

  if (length(strings) == 0 || any(lengths(strings) == 0)) {
    if (length(collapse) == 0) return(character(0))
    return("")
  }

  max_length <- max(lengths(strings))

  result <- lapply(strings, rep_len, length.out = max_length)
  result <- do.call(cbind, result)
  result <- apply(result, 1, paste, collapse = sep)
  result <- paste(result, collapse = collapse)

  result
}

#' Detect the presence or absence of a pattern in a string
#'
#' Dependency-free drop-in alternative for `stringr::str_detect()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @param negate If `TRUE`, return non-matching elements.
#'
#' @return A logical vector.
#' @noRd
str_detect <- function(string, pattern, negate = FALSE) {
  if (length(string) == 0 || length(pattern) == 0) return(logical(0))

  is_fixed <- inherits(pattern, "stringr_fixed")

  indices <- Vectorize(grep, c("pattern", "x"), USE.NAMES = FALSE)(
    pattern,
    x = string,
    perl = !is_fixed,
    fixed = is_fixed,
    invert = negate
  )

  result <- as.logical(lengths(indices))
  result[is.na(string)] <- NA
  result
}

#' Extract matching patterns from a string
#'
#' Dependency-free drop-in alternative for `stringr::str_extract()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @return A character matrix.
#'   The first column is the complete match,
#'   followed by one column for each capture group.
#' @noRd
str_extract <- function(string, pattern) {
  if (length(string) == 0 || length(pattern) == 0) return(character(0))

  is_fixed <- inherits(pattern, "stringr_fixed")

  result <- Map(
    function(string, pattern) {
      if (is.na(string) || is.na(pattern)) return(NA_character_)

      regmatches(
        x = string,
        m = regexpr(
          pattern = pattern, text = string, perl = !is_fixed, fixed = is_fixed
        )
      )
    },
    string, pattern, USE.NAMES = FALSE
  )

  result[lengths(result) == 0] <- NA_character_
  unlist(result)
}

#' @name str_extract_fileext
#' @rdname str_fileext
#' @noRd
str_extract_fileext <- function(string, fileext = NULL) {
  if (is.null(fileext)) {
    fileext <- "[a-zA-Z0-9]+"
  }

  str_extract(string, paste0("(?<=\\.)", fileext, "$(?!\\.)"))
}

#' Duplicate and concatenate strings within a character vector
#'
#' Dependency-free drop-in alternative for `stringr::str_pad()`.
#'
#' @author Eli Pousson \email{eli.pousson@gmail.com}
#'   ([ORCID](https://orcid.org/0000-0001-8280-1706))
#'
#'   Alexander Rossell Hayes \email{alexander@rossellhayes.com}
#'   ([ORCID](https://orcid.org/0000-0001-9412-0457))
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#' @param width Minimum width of padded strings.
#' @param side Side on which padding character is added (left, right or both).
#' @param pad Single padding character (default is a space).
#' @param use_width If `FALSE`,
#'   use the length of the string instead of the width;
#'   see [str_width()]/[str_length()] for the difference.
#'
#' @return A character vector.
#' @noRd
str_pad <- function(
    string, width, side = c("left", "right", "both"), pad = " ", use_width = TRUE
) {
  if (!is.numeric(width)) {
    return(string[NA])
  }

  if (any(nchar(pad, type = "width") != 1)) {
    stop("each string in `pad` should consist of code points of total width 1")
  }

  side <- match.arg(side)

  nchar_type <- if (isTRUE(use_width)) "width" else "chars"
  string_width <- nchar(string, nchar_type)
  pad_width <- width - string_width
  pad_width[pad_width < 0] <- 0

  switch(
    side,
    "left" = paste0(strrep(pad, pad_width), string),
    "right" = paste0(string, strrep(pad, pad_width)),
    "both" = paste0(
      strrep(pad, floor(pad_width / 2)),
      string,
      strrep(pad, ceiling(pad_width / 2))
    )
  )
}

#' Remove matched patterns in a string
#'
#' Dependency-free drop-in alternative for `stringr::str_remove()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @return A character vector.
#' @noRd
str_remove <- function(string, pattern) {
  if (length(string) == 0 || length(pattern) == 0) return(character(0))
  is_fixed <- inherits(pattern, "stringr_fixed")
  Vectorize(sub, c("pattern", "x"), USE.NAMES = FALSE)(
    pattern, replacement = "", x = string, perl = !is_fixed, fixed = is_fixed
  )
}

#' @name str_remove_fileext
#' @rdname str_fileext
#' @noRd
str_remove_fileext <- function(string, fileext = NULL) {
  if (is.null(fileext)) {
    fileext <- str_extract_fileext(string)
  }

  str_remove(string, paste0("\\.", fileext, "$"))
}

#' Convert to a common sentence case
#'
#' @author Joachim Schork \email{info@joachimschork.com}
#'
#' @source [Statistics Globe](https://statisticsglobe.com/r-capitalize-first-letter-of-character-string-containing-multiple-words)
#'
#' @param x a character vector, or an object that can be coerced to character by
#'   [as.character()].
#' @noRd
tosentence <- function(x) {
  gsub("(^|[[:space:]])([[:alpha:]])", "\\1\\U\\2", x, perl = TRUE)
}
# Generated by staticimports; do not edit by hand.
# ======================================================================
# Imported from pkg:stringstatic
# ======================================================================

#' Control regex matching behavior
#'
#' Dependency-free drop-in alternative for `stringr::regex()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param pattern Pattern to modify behavior.
#' @param ignore_case Should case differences be ignored in the match?
#' @param multiline
#'   If `TRUE`, `$` and `^` match the beginning and end of each line.
#'   If `FALSE`, the default, only match the start and end of the input.
#' @param comments
#'   If `TRUE`, white space and comments beginning with `#` are ignored.
#'   Escape literal spaces with `\\`.
#' @param dotall If `TRUE`, `.` will also match line terminators.
#'
#' @return An integer vector.
#' @noRd
regex <- function(
	pattern,
	ignore_case = FALSE,
	multiline = FALSE,
	comments = FALSE,
	dotall = FALSE
) {
	options <- paste(
		if (isTRUE(ignore_case)) "i",
		if (isTRUE(multiline)) "m",
		if (isTRUE(dotall)) "s",
		if (isTRUE(comments)) "x",
		sep = ""
	)

	if (nzchar(options)) {
		if (!is.null(names(pattern))) {
			names(pattern) <- paste0("(?", options, ")", names(pattern))
		} else {
			pattern <- paste0("(?", options, ")", pattern)
		}
	}

	structure(pattern, class = c("stringr_regex", "stringr_pattern", "character"))
}

#' Detect the presence or absence of a pattern in a string
#'
#' Dependency-free drop-in alternative for `stringr::str_detect()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @param negate If `TRUE`, return non-matching elements.
#'
#' @return A logical vector.
#' @noRd
str_detect <- function(string, pattern, negate = FALSE) {
	if (length(string) == 0 || length(pattern) == 0) return(logical(0))

	is_fixed <- inherits(pattern, "stringr_fixed")

	indices <- Vectorize(grep, c("pattern", "x"), USE.NAMES = FALSE)(
		pattern,
		x = string,
		perl = !is_fixed,
		fixed = is_fixed,
		invert = negate
	)

	result <- as.logical(lengths(indices))
	result[is.na(string)] <- NA
	result
}

#' Extract matching patterns from a string
#'
#' Dependency-free drop-in alternative for `stringr::str_extract()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @return A character matrix.
#'   The first column is the complete match,
#'   followed by one column for each capture group.
#' @noRd
str_extract <- function(string, pattern) {
	if (length(string) == 0 || length(pattern) == 0) return(character(0))

	is_fixed <- inherits(pattern, "stringr_fixed")

	result <- Map(
		function(string, pattern) {
			if (is.na(string) || is.na(pattern)) return(NA_character_)

			regmatches(
				x = string,
				m = regexpr(
					pattern = pattern, text = string, perl = !is_fixed, fixed = is_fixed
				)
			)
		},
		string, pattern, USE.NAMES = FALSE
	)

	result[lengths(result) == 0] <- NA_character_
	unlist(result)
}

#' Remove matched patterns in a string
#'
#' Dependency-free drop-in alternative for `stringr::str_remove()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @return A character vector.
#' @noRd
str_remove <- function(string, pattern) {
	if (length(string) == 0 || length(pattern) == 0) return(character(0))
	is_fixed <- inherits(pattern, "stringr_fixed")
	Vectorize(sub, c("pattern", "x"), USE.NAMES = FALSE)(
		pattern, replacement = "", x = string, perl = !is_fixed, fixed = is_fixed
	)
}

#' Replace matched patterns in a string
#'
#' Dependency-free drop-in alternative for `stringr::str_replace()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @param replacement A character vector of replacements.
#'   Should be either length one, or the same length as `string` or `pattern`.
#'   References of the form `\1`, `\2`, etc. will be replaced with the contents
#'   of the respective matched group (created by `()`).
#'
#'   To replace the complete string with `NA`,
#'   use `replacement = NA_character_`.
#'
#'   Using a function for `replacement` is not yet supported.
#'
#' @return A character vector.
#' @noRd
str_replace <- function(string, pattern, replacement) {
	if (length(string) == 0 || length(pattern) == 0 || length(replacement) == 0) {
		return(character(0))
	}

	is_fixed <- inherits(pattern, "stringr_fixed")

	Vectorize(sub, c("pattern", "replacement", "x"), USE.NAMES = FALSE)(
		pattern, replacement, x = string, perl = !is_fixed, fixed = is_fixed
	)
}
