% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_measurements.R
\name{get_measurements}
\alias{get_measurements}
\alias{get_area}
\alias{get_length}
\alias{get_dist}
\alias{get_bearing}
\alias{st_bearing}
\title{Get measurements for simple feature objects}
\usage{
get_area(x, units = NULL, keep_all = TRUE, drop = FALSE, .id = "area")

get_length(x, units = NULL, keep_all = TRUE, drop = FALSE, .id = "length")

get_dist(
  x,
  to,
  by_element = TRUE,
  units = NULL,
  drop = FALSE,
  keep_all = TRUE,
  .id = "dist",
  ...
)

get_bearing(x, dir = FALSE, keep_all = TRUE, .id = "bearing")
}
\arguments{
\item{x}{A \code{sf} or \code{sfc} object to measure.}

\item{units}{Units to return for area, length, perimeter, or distance;
Default: \code{NULL}}

\item{keep_all}{If \code{TRUE}, return all columns from the original object,
Default: \code{TRUE}}

\item{drop}{If \code{TRUE}, drop units from the line lengths, Default: \code{FALSE}}

\item{.id}{Column name to use for area, line length/perimeter, distance, or
bearing.}

\item{to}{A \code{sf}, \code{sfc}, or \code{bbox} object or a length 2 character vector. If
"to" is an \code{sf} or \code{sfc} object, it must have either a single feature or
the same number of features as x (if by_element is \code{TRUE}). If "to" is a
character vector it must represent a valid xy pair using the following
options: "xmin", "ymin", "xmax", "ymax", "xmid", "ymid".}

\item{by_element}{logical; if \code{TRUE}, return a vector with distance between the first elements of \code{x} and \code{y}, the second, etc. if \code{FALSE}, return the dense matrix with all pairwise distances.}

\item{...}{passed on to \link[s2]{s2_distance} or \link[s2]{s2_distance_matrix}}

\item{dir}{Logical indicator whether to include direction in bearing; If
\code{FALSE}, return the absolute (positive) bearing value. If \code{TRUE}, return
negative and positive bearing values. Default: \code{FALSE}.}
}
\description{
Get measurements for simple feature objects
}
\details{
Wrapper functions for \link[sf:geos_measures]{sf::geos_measures}:
\itemize{
\item \link{get_area}: Wraps on \link[sf:geos_measures]{sf::st_area} but MULTIPOINT or MULTILINESTRING
geometry is converted to a polygon using \link[sf:geos_unary]{sf::st_polygonize} which is used to
determine the coverage area.
\item \link{get_length}: Wraps to \link[sf:geos_measures]{sf::st_length} but POINT and MULTIPOINT geometry is
converted to LINESTRING using \link{as_lines}. If x has POLYGON geometry,
\link[lwgeom:perimeter]{lwgeom::st_perimeter} is used to return the perimeter instead of the length.
\item \link{get_dist}: Wraps \link[sf:geos_measures]{sf::st_distance} but x is converted to a POINT using
\link{st_center} and "to" can be a POINT, a sf object that can be converted to a
POINT, or a character vector indicating a point on the overall bounding box
for x.
}

Additional measurement functions:
\itemize{
\item \link{get_bearing}: Wraps \link[geosphere:bearing]{geosphere::bearing}.
}
}
\examples{
nc <- read_sf_path(system.file("shape/nc.shp", package = "sf"))

# Get area for North Caroline counties
get_area(nc[1:2,])$area
get_area(nc[1:2,], units = "acres")$area
get_area(nc[1:2,], units = "acres", .id = "acreage")$acreage

# Get distances for North Caroline counties
get_dist(nc[1,], to = c("xmax", "ymax"), units = "mile")$dist
get_dist(nc[1,], to = nc[30,], units = "km")$dist

# Create a line between two counties
nc_line <- as_line(c(as_point(nc[1,]), as_point(nc[30,])), crs = nc)

# Get length and bearing of the line
get_length(nc_line)
get_bearing(nc_line)
}
\seealso{
Other dist: 
\code{\link{convert_dist_scale}()},
\code{\link{convert_dist_units}()},
\code{\link{is_dist_units}()},
\code{\link{sf_bbox_misc}}
}
\concept{dist}
