% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/count_sf_ext.R
\name{count_sf_ext}
\alias{count_sf_ext}
\title{Count extended for working with sf objects}
\usage{
count_sf_ext(
  data,
  x = NULL,
  y = NULL,
  join = sf::st_intersects,
  largest = TRUE,
  wt = NULL,
  sort = FALSE,
  replace_na = FALSE,
  keep_na = FALSE,
  lims = NULL,
  geometry = TRUE,
  .id = "id",
  name = NULL,
  ...
)
}
\arguments{
\item{data}{Data to count in relationship to y}

\item{x}{Optional sf object passed to \code{\link[=st_make_grid_ext]{st_make_grid_ext()}}. Defaults to \code{NULL}.}

\item{y}{If \code{NULL} (default), y defaults to an \code{sf} object created by \code{\link[=st_make_grid_ext]{st_make_grid_ext()}} using x or data (if x is
\code{NULL}) as the x parameter for \code{\link[=st_make_grid_ext]{st_make_grid_ext()}}. If not \code{NULL}, y must be an \code{sf} object that
has a column with the same name as .id (defaults to "id").}

\item{join}{geometry predicate function with the same profile as \link[sf]{st_intersects}; see details}

\item{largest}{logical; if \code{TRUE}, return \code{x} features augmented with the fields of \code{y} that have the largest overlap with each of the features of \code{x}; see https://github.com/r-spatial/sf/issues/578}

\item{wt}{<\code{\link[dplyr:dplyr_data_masking]{data-masking}}> Frequency weights.
Can be \code{NULL} or a variable:
\itemize{
\item If \code{NULL} (the default), counts the number of rows in each group.
\item If a variable, computes \code{sum(wt)} for each group.
}}

\item{sort}{If \code{TRUE}, will show the largest groups at the top.}

\item{replace_na}{If \code{TRUE}, replace NA values from count with 0. If \code{FALSE},
filter NA values from the returned object.}

\item{geometry}{If \code{TRUE} (default) return a \code{sf} object. If \code{FALSE}, return
a data frame.}

\item{name}{The name of the new column in the output.

If omitted, it will default to \code{n}. If there's already a column called \code{n},
it will error, and require you to specify the name.}

\item{...}{
  Arguments passed on to \code{\link[=st_make_grid_ext]{st_make_grid_ext}}
  \describe{
    \item{\code{ncol,nrow}}{Used to set n if either are not \code{NULL}; defaults to \code{NULL}.
row and id are added as columns to the grid if they are provided.}
    \item{\code{gutter}}{Distance in units between each column cell; gutter effectively
serves as a margin as the negative buffer is applied to all cells
(including those at the edges of the grid).}
    \item{\code{desc}}{If TRUE, reverse standard order of cell id numbering; defaults
\code{FALSE}}
    \item{\code{n}}{If n is NULL and square is \code{TRUE}, the grid is set automatically to
be 10 cells wide, Default: \code{NULL}}
    \item{\code{what}}{"polygons", "corners", "centers"; set to centers automatically if
style is "circle", "circle_offset" but a buffer is applied to return
circular polygons.}
    \item{\code{style}}{Style of cell to return with options including "rect", "square",
"hex", "flat_top_hex", "circle", "circle_offset"}
    \item{\code{filter}}{If \code{TRUE} (or if trim is \code{TRUE}) filter grid geometry by x
using \link{st_filter_ext}}
    \item{\code{crs}}{Coordinate reference system of bounding box to return; defaults to
\code{NULL} which maintains the crs of the input object.}
    \item{\code{unit}}{Units for buffer. Supported options include "meter", "foot",
"kilometer", and "mile", "nautical mile" Common abbreviations (e.g. "km"
instead of "kilometer") are also supported. Distance in units is converted
to units matching GDAL units for x; defaults to "meter"}
    \item{\code{cellsize}}{target cellsize}
    \item{\code{trim}}{If \code{TRUE}, x is trimmed to y with \code{\link[=st_trim]{st_trim()}}.}
  }}

\item{count_lims}{Optional numeric vector with minimum or both minimum and
maximum count values. If provided, any values below the minimum are set to
that minimum and any values above the maximum as set to the maximum. If
only one value is provided, it is assumed to be a minimum limit.}
}
\description{
An extended version of \code{\link[dplyr:count]{dplyr::count()}} that makes it easier to count the
occurrences of features from data that intersect with features from a second
sf object (set by y) or created by passing x or data to \code{\link[=st_make_grid_ext]{st_make_grid_ext()}}.
}
\examples{
nc <- sf::read_sf(path = system.file("shape/nc.shp", package = "sf"))
data <- sf::st_sample(nc, size = 75)

# Count data based on nc
count <- count_sf_ext(data = data, y = nc, .id = "FIPS")
plot(count[, "n"], pal = heat.colors(n = max(count$n), alpha = 0.5), reset = FALSE)
plot(data, add = TRUE, pch = 20)

# Count data based grid created by passing nc to st_make_grid_ext
count_grid <- count_sf_ext(data = data, x = nc, .id = "FIPS")
plot(count_grid[, "n"], pal = heat.colors(n = max(count_grid$n), alpha = 0.5), reset = FALSE)
plot(data, add = TRUE, pch = 20)

}
